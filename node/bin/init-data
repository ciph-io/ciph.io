#!/usr/bin/env node

'use strict'

/* native modules */
const path = require('path')

/* npm modules */
const crypto = require('mz/crypto')
const defined = require('if-defined')
const fs = require('fs-extra')
const requestPromise = require('request-promise')
const touch = require('touch')

/* initialize process.env */
require('../lib/config')

/* app modules */
const BlockService = require('../lib/block-service')
const ServerService = require('../lib/server-service')
const blockId = require('../lib/util/block-id')

/* globals */
const hexChars = [0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e','f']
// table of files that need to be created
const createdFiles = []
// table of file sizes in bytes
const bytesBySize = BlockService.getBlockSizes()
// current server
const server = ServerService.getServer()
assert(server.type === 'data', 'must run init-data on data server')
// get web server
const webServer = ServerService.getWebServer()

initData().catch(console.error)

async function initData () {
    const dataDirs = server.dataDirs
    // make sure that all data directories exist
    for (const dataDir of dataDirs) {
        // make sure directory exists
        await fs.ensureDir(dataDir)
        // create file that will be used for setting times
        const timeFilePath = path.resolve(dataDir, 'time.file')
        await fs.writeFile(timeFilePath, '1')
        await fs.utimes(timeFilePath, 946684799, 946684799)
    }
    // get directories for each prefix
    const prefixDirs = getPrefixDirs(server.shardPrefix)
    // get number of prefix directories
    const numDirs = prefixDirs.length / server.shards
    // get number of prefix directories per data dir
    const subDirs = numDirs / dataDirs.length
    // create prefix dir and random files
    for (const prefixDir of prefixDirs) {
        // skip if data server does not server this prefix
        if (prefixDir.int % server.shards !== server.shard) {
            continue
        }
        // bucket prefix dirs into data dirs sequenitally
        const dataDirNum = Math.floor(prefixDir.int / server.shards / subDirs)
        // if only a single dir is set then skip if not that dir
        if (process.env.INIT_DATA_DIR && process.env.INIT_DATA_DIR != dataDirNum) {
            console.log('skipping', dataDirNum)
            continue
        }
        // get data dir for prefix
        const dataDir = dataDirs[dataDirNum]
        // get path for prefix dir under correct data dir
        const prefixDirPath = path.resolve(dataDir, prefixDir.hex)
        // get path for time file
        const timeFilePath = path.resolve(dataDir, 'time.file')
        // create prefix dir
        await fs.ensureDir(prefixDirPath)
        // create size dir
        for (let i=0; i < bytesBySize.length; i++) {
            // number of bytes for this size
            const bytes = bytesBySize[i]
            // get path for size under prefix dir
            const sizeDirPath = path.resolve(prefixDirPath, i.toString())
            // create size dir
            await fs.ensureDir(sizeDirPath)
            // create random file in path
            await createRandomFile(sizeDirPath, i, bytes, prefixDir.hex, timeFilePath)
        }

    }

}

async function createRandomFile (sizeDirPath, size, bytes, prefix, timeFilePath) {
    let data
    let digest

    // get random data with matching hash prefix
    while (true) {
        data = await crypto.randomBytes(bytes)
        digest = blockId(data)
        // prefix matches
        if (digest.substr(0, prefix.length) === prefix) {
            // try to register block id - will error if exists
            try {
                await requestPromise({
                    body: { blockId: digest, size: size },
                    json: true,
                    method: 'POST',
                    uri: `${webServer.url}/publish/start`,
                })
                // break loop on success
                break
            }
            catch (err) {
                console.error(err.message)
            }
        }
    }

    const filePath = path.resolve(sizeDirPath, `${digest}.ciph`)

    console.log(`saving file ${filePath}`)

    // save file
    await fs.writeFile(filePath, data)
    // set times on file to match time file
    await touch(filePath, {ref: timeFilePath})

    // create publish signature
    const signature = ServerService.getServerSignature(size+digest+server.id)

    // finish publish
    await requestPromise({
        body: {
            blockId: digest,
            serverId: server.id,
            signature: signature,
            size: size,
        },
        json: true,
        method: 'POST',
        uri: `${webServer.url}/publish/finish`,
    })
}

function getPrefixDirs (prefixLength) {
    const dataDirs = []

    if (prefixLength === 2) {
        for (const a of hexChars) {
            for (const b of hexChars) {
                const prefix = `${a}${b}`

                dataDirs.push({
                    hex: prefix,
                    int: parseInt(prefix, '16'),
                })
            }
        }
    }
    else if (prefixLength === 3) {
        for (const a of hexChars) {
            for (const b of hexChars) {
                for (const c of hexChars) {
                    const prefix = `${a}${b}${c}`
                    
                    dataDirs.push({
                        hex: prefix,
                        int: parseInt(prefix, '16'),
                    })
                }
            }
        }
    }
    else {
        throw new Error('invalid prefix length')
    }

    return dataDirs
}